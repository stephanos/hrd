package hrd

import (
	"time"
)

// Saver can save entities to a Collection.
type Saver struct {
	coll *Collection
	opts *operationOpts
}

// newSaver creates a new Saver for the passed store.
// The collection's options are used as default options.
func newSaver(coll *Collection) *Saver {
	return &Saver{coll, coll.opts.clone()}
}

// Opts applies the passed sequence of Opt to the Saver's options.
func (s *Saver) Opts(opts ...Opt) *Saver {
	s.opts = s.opts.Apply(opts...)
	return s
}

// ReqKey defines whether an entity requires a complete key.
// If no parameter is passed, true is assumed.
func (s *Saver) ReqKey(complete ...bool) *Saver {
	s.opts = s.opts.CompleteKeys(complete...)
	return s
}

// ==== CACHE

// NoCache prevents writing entities to
// the in-memory cache or memcache in this save operation.
func (s *Saver) NoCache() *Saver {
	return s.NoLocalCache().NoGlobalCache()
}

// NoLocalCache prevents writing entities to
// the in-memory cache in this save operation.
func (s *Saver) NoLocalCache() *Saver {
	s.opts = s.opts.NoLocalCache()
	return s
}

// NoGlobalCache prevents writing entities to
// memcache in this save operation.
func (s *Saver) NoGlobalCache() *Saver {
	return s.CacheExpire(-1)
}

// CacheExpire sets the expiration time in memcache for entities
// that are cached after saving them to the datastore.
func (s *Saver) CacheExpire(exp time.Duration) *Saver {
	s.opts = s.opts.CacheExpire(exp)
	return s
}

// ==== EXECUTE

// Entity saves the passed entity into the datastore.
// If its key is incomplete, the returned key will
// be a unique key generated by the datastore.
func (s *Saver) Entity(src interface{}) (*Key, error) {
	keys, err := s.put(src)
	if len(keys) == 1 {
		return keys[0], err
	}
	return nil, err
}

// Entities saves the passed entities into the datastore.
// If an entity's key is incomplete, the returned keys will
// contain a unique key generated by the datastore.
func (s *Saver) Entities(srcs interface{}) ([]*Key, error) {
	return s.put(srcs)
}

func (s *Saver) put(src interface{}) ([]*Key, error) {
	docs, err := newReadableDocs(s.coll, src)
	if err != nil {
		return nil, err
	}
	return s.coll.store.putMulti(s.coll.name, docs, s.opts)
}
